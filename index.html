<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2MKN0K723F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-2MKN0K723F');
  </script>

  <title>Weekly Circular</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #ffffff;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
  </style>
</head>
<body>

  <iframe id="circularFrame" title="Weekly Store Circular"></iframe>

  <script>
    // Manifest file generated by GitHub Actions (repo root)
    const MANIFEST_URL = "./circular-manifest.json";

    // Rollover time zone (Friday 12:00 AM)
    const ROLLOVER_TZ = "America/New_York";

    // Filename format:
    // GC + (YYYY + 0MMDD) + _Merged.pdf
    // Example: GC202600116_Merged.pdf
    const FILE_REGEX = /^GC(\d{4})(\d{5})_Merged\.pdf$/i;

    function cacheBusted(url) {
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    function getNowPartsInTZ(timeZone) {
      const dtf = new Intl.DateTimeFormat("en-US", {
        timeZone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      });
      const parts = dtf.formatToParts(new Date());
      const map = {};
      for (const p of parts) map[p.type] = p.value;
      return {
        year: Number(map.year),
        month: Number(map.month),
        day: Number(map.day),
        hour: Number(map.hour),
        minute: Number(map.minute),
        second: Number(map.second)
      };
    }

    function getWeekdayInTZ(timeZone) {
      const wd = new Intl.DateTimeFormat("en-US", { timeZone, weekday: "short" }).format(new Date());
      const map = { Sun:0, Mon:1, Tue:2, Wed:3, Thu:4, Fri:5, Sat:6 };
      return map[wd];
    }

    // Build a surrogate Date using TZ parts (used only for day arithmetic)
    function getNowDateInTZSurrogate(timeZone) {
      const p = getNowPartsInTZ(timeZone);
      return new Date(Date.UTC(p.year, p.month - 1, p.day, p.hour, p.minute, p.second));
    }

    function mmddTo5(month, day) {
      // Returns 0MMDD as a 5-digit string (e.g., Jan 16 => "00116")
      const mm = String(month).padStart(2, "0");
      const dd = String(day).padStart(2, "0");
      return "0" + mm + dd;
    }

    // Effective circular date key is the most recent Friday in America/New_York
    // Key format: YYYY + 0MMDD  (e.g., 2026 + 00116 => "202600116")
    function getEffectiveFridayKey(timeZone) {
      const weekday = getWeekdayInTZ(timeZone); // 0..6
      const nowSur = getNowDateInTZSurrogate(timeZone);

      // Back to most recent Friday (Fri=5)
      const back = (weekday - 5 + 7) % 7; // 0 on Fri, 1 on Sat, etc.
      const recentFri = new Date(nowSur.getTime() - back * 24 * 60 * 60 * 1000);

      // Extract year/month/day in the target TZ from that date
      const dtf = new Intl.DateTimeFormat("en-US", {
        timeZone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      });
      const parts = dtf.formatToParts(recentFri);
      const year = Number(parts.find(x => x.type === "year").value);
      const month = Number(parts.find(x => x.type === "month").value);
      const day = Number(parts.find(x => x.type === "day").value);

      return String(year) + mmddTo5(month, day); // "YYYY0MMDD"
    }

    function extractKey(filename) {
      const m = filename.match(FILE_REGEX);
      if (!m) return null;
      const year = m[1];     // "2026"
      const mmdd5 = m[2];    // "00116"
      return year + mmdd5;   // "202600116"
    }

    function chooseBestFile(files, effectiveKey) {
      const eff = Number(effectiveKey);
      let best = null;
      let bestVal = -1;

      for (const f of files) {
        const k = extractKey(f);
        if (!k) continue;
        const v = Number(k);

        // Only allow <= effective week, so future uploads never show early
        if (v <= eff && v > bestVal) {
          bestVal = v;
          best = f;
        }
      }
      return best;
    }

    function newestFile(files) {
      let newest = null;
      let newestVal = -1;
      for (const f of files) {
        const k = extractKey(f);
        if (!k) continue;
        const v = Number(k);
        if (v > newestVal) {
          newestVal = v;
          newest = f;
        }
      }
      return newest;
    }

    function setIframe(fileName) {
      // PDFs are in repo root
      document.getElementById("circularFrame").src = "./" + encodeURIComponent(fileName);
    }

    // Optional: if someone leaves the tab open, reload at Friday 00:00 America/New_York
    function scheduleRolloverReload(timeZone) {
      const intervalMs = 60 * 1000; // check each minute
      const timer = setInterval(() => {
        const p = getNowPartsInTZ(timeZone);
        const wd = getWeekdayInTZ(timeZone);
        if (wd === 5 && p.hour === 0 && p.minute === 0) {
          clearInterval(timer);
          location.reload();
        }
      }, intervalMs);
    }

    async function main() {
      const effectiveKey = getEffectiveFridayKey(ROLLOVER_TZ);

      const res = await fetch(cacheBusted(MANIFEST_URL), {
        headers: { "Accept": "application/json" }
      });
      if (!res.ok) throw new Error(`Manifest fetch failed: ${res.status}`);

      const manifest = await res.json();
      const files = Array.isArray(manifest.files) ? manifest.files : [];

      const best = chooseBestFile(files, effectiveKey) || newestFile(files);
      if (best) setIframe(best);

      scheduleRolloverReload(ROLLOVER_TZ);
    }

    main().catch(console.error);
  </script>

</body>
</html>
